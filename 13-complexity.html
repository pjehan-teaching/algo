<section id="complexity">

    <section>
        <h2>Complexité</h2>
    </section>

    <section>
        <h2>Complexité conceptuelle et complexité algorithmique</h2>
        <ul>
            <li>La <strong>complexité conceptuelle</strong> d'un algorithme est la difficulté à le <strong>comprendre</strong>.</li>
            <li>La <strong>complexité algorithmique</strong> s'intéresse à l'<strong>efficacité</strong> d'un algorithme.</li>
            <li>Un algorithme plus efficace peut être plus difficile à comprendre.</li>
            <li>Il s'agit d'un <strong>compromis</strong> entre la complexité conceptuelle et la complexité algorithmique.</li>
        </ul>
    </section>

    <section>
        <h2>Approximation</h2>
        <p>Afin de mesurer la complexité algorithmique, on utilise une <strong>approximation</strong> de la complexité.</p>
        <p>L'objectif sera de mesurer la complexité sans prendre de mesures et sans prendre en compte les performances de notre ordinateur.</p>
        <p>Nous allons pour cela nous contenter de <strong>compter le nombre d'instructions</strong>.</p>
    </section>

    <section>
        <h2>Approximation</h2>
        <p>Pour effectuer notre approximation, nous partirons donc du principe que toutes les instructions prennent un <strong>temps fixe identique</strong>.</p>
        <p>Il s'agit d'une approximation, car en réalité, certaines instructions prennent plus de temps que d'autres.</p>
        <p>Par exemple, une multiplication prend plus de temps qu'une addition.</p>
    </section>

    <section>
        <h2>Fonction des entrées</h2>
        <p>La complexité algorithmique dépend de la <strong>fonction des entrées</strong>.</p>
        <p>La fonction des entrées est la fonction qui permet de calculer le nombre d'instructions en fonction de la <strong>taille des entrées</strong>.</p>
        <p>Par exemple, si la fonction des entrées est <code>f(n) = n</code>, alors la complexité algorithmique est linéaire.</p>
    </section>

    <section>
        <h2>Loi de Murphy</h2>
        <p>La <strong>loi de Murphy</strong> nous dit que <strong>tout ce qui peut mal tourner va mal tourner</strong>.</p>
        <p>En programmation, cela signifie que <strong>le pire des cas</strong> va se produire.</p>
        <p>Nous allons rechercher le pire des cas afin de mesurer la complexité algorithmique.</p>
    </section>

    <section>
        <h2>Complexité temporelle et spatiale</h2>
        <p>Il existe deux types de complexité algorithmique :</p>
        <ul>
            <li>La <strong>complexité temporelle</strong> qui mesure le temps d'exécution d'un algorithme.</li>
            <li>La <strong>complexité spatiale</strong> qui mesure la mémoire utilisée par un algorithme.</li>
        </ul>
        <p>
            Nous n'allons pas aborder ensemble la complexité spatiale, car celle-ci doit être considérée uniquement
            si 2 algorithmes ont une complexité temporelle similaire.
        </p>
    </section>

    <section>
        <h3>Big O notation (notation de Landau)</h3>
        <p>La <strong>Big O notation</strong> est une notation mathématique qui permet de représenter la complexité algorithmique.</p>
        <p>Elle permet de représenter la complexité algorithmique en fonction de la <strong>taille des entrées</strong> et en considérant le <strong>pire des cas</strong>.</p>
        <ul>
            <li>La complexité d'un algorithme constant est notée <code>O(1)</code>.</li>
            <li>La complexité d'un algorithme logarithmique est notée <code>O(log n)</code>.</li>
            <li>La complexité d'un algorithme linéaire est notée <code>O(n)</code>.</li>
            <li>La complexité d'un algorithme quadratique est notée <code>O(n^2)</code>.</li>
            <li>La complexité d'un algorithme exponentiel est notée <code>O(2^n)</code>.</li>
        </ul>
    </section>

    <section>
        <h3>Big O notation</h3>
        <p>
            Ces complexités peuvent être représentées graphiquement :
        </p>
        <figure>
            <img src="assets/images/complexity-chart.jpg" alt="Graphique de complexité algorithmique">
            <figcaption>Graphique de complexité algorithmique</figcaption>
        </figure>
    </section>

    <section>
        <h3>Exemple - Constante</h3>
        <p>
            Un algorithme qui affiche la valeur d'un élément d'un tableau a un index fixe à une complexité constante :
        </p>
        <div data-alg="assets/files/complexity-constant.alg"></div>
    </section>

    <section>
        <h3>Exemple - Logarithmique</h3>
        <p>
            Un algorithme qui affiche la liste des puissances de 2 jusqu'à un nombre donné a une complexité logarithmique :
        </p>
        <div data-alg="assets/files/complexity-logarithmic.alg"></div>
    </section>

    <section>
        <h3>Exemple - Linéaire</h3>
        <p>
            Une simple boucle qui parcourt un tableau de <code>n</code> éléments a une complexité linéaire :
        </p>
        <div data-alg="assets/files/complexity-linear.alg"></div>
    </section>

    <section>
        <h3>Exemple - Quadratique</h3>
        <p>
            Une double boucle qui parcourt un tableau de <code>n</code> éléments a une complexité quadratique :
        </p>
        <div data-alg="assets/files/complexity-quadratic.alg"></div>
    </section>

    <section>
        <h3>Exemple - Exponentielle</h3>
        <p>
            Un algorithme permettant de trouver un mot de passe par la méthode de la force brute (brute force)
            a une complexité exponentielle :
        </p>
        <div data-alg="assets/files/complexity-exponential.alg"></div>
    </section>

    <section>
        <h3>Exercice</h3>
        <div class="instructions">
            <ol>
                <li>Quelle est la complexité de l'algorithme de rechercher dichotomique ?</li>
                <li>Quelle est la complexité de l'algorithme pour recherche un nombre dans la suite de Fibonacci ?</li>
            </ol>
        </div>
    </section>

</section>
